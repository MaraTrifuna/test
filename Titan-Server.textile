[[https://raw.github.com/thinkaurelius/titan/master/doc/images/titan-server-embedded.png
|width=200px|align=right|float]]

Titan Server is a [[Gremlin|Gremlin Query Language]] server for the Titan graph database. It manages remote connections to the Titan graph database and thereby allows applications to execute Gremlin queries against a Titan graph cluster. Titan Server builds on RexPro, a light-weight component of the Rexster Server which can efficiently handle hundreds of database connections.

h3. Start Titan Server

To start the Titan Server, execute the titan script in the bin folder of the Titan distribution.

```bash
$ ./bin/titan.sh rexster-config.xml titan-config.properties
```

The script expects two arguments:

# A configuration file for the Rexpro server. Refer to the Rexpro section of the "Rexster configuration documentation":https://github.com/tinkerpop/rexster/wiki/Rexster-Configuration for more information on how to configure the Rexpro connection manager of Titan Server. This first argument is optional and can be omitted, in which case default configurations are used for Rexpro.
# A configuration file for the Titan graph database. Refer to the [[Graph Configuration]] documentation for more information.

After starting the server it can be terminated pressing CTRL+C or sending the corresponding kill signal to the process.

h3. Connecting to Titan Server

The client application can now connect to the Titan Server on the configured hostname and port to issue gremlin queries using @RexsterTitanClient@.

```java
RexsterTitanClient client = new RexsterTitanClient("127.0.0.1");
List<Map<String,Object>> result;
result = client.query("g.V('name','saturn').in('father').map");

Map<String,Object> paras = new HashMap<String,Object>();
paras.put("name","saturn");
result = client.query("g.V('name',name).in('father').map",paras);
client.close();
```

First, a connection to the Titan Server is established. 
Gremlin queries are issued as strings using the @RexsterTitanClient.query()@ methods. Each query is executed in its own transaction. Explicit transaction handling is not necessary.
The result set is a list of query answers, where each query answer is represented as a map of key-value pairs. @RexsterTitanClient@ provides additional @query()@ methods where the signature of each query answer can be specified as a template.
The second query is semantically identical to the first, but in this case we are passing in the name as a variable binding for the corresponding variable used in the query.

Once all queries have been issued, the connection is closed.

h3. Titan Embedding

Titan Server is most useful when Titan runs embedded with the storage backend of choice. Under such a deployment scenario, Titan, Rexster, and the storage backend run in the same JVM. This makes calls between the components very efficient and leads to the best performing setup. Refer to the documentation of the respective [[storage backends|Storage Backend Overview]] for information on how to run Titan embedded.


h2. Next Steps

* Read the [[Storage Backend Overview]] for more information on choosing and configuring a storage backend for Titan.
* Titan Server builds on RexPro, a component of the Rexster Server. Learn about the full [[Rexster Graph Server]] that exposes any Titan graph as a REST endpoint.