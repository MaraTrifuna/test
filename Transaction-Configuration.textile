Titan's @TitanGraph.buildTransaction()@ method gives the user the ability to configure and start a new [[thread-independent transaction|Multi-Threaded-Transactions]] against a @TitanGraph@. Hence, it is identical to @TitanGraph.newTransaction()@ with additional configuration options.

@buildTransaction()@ returns a @TransactionBuilder@ which allows the following aspects of a transaction to be configured:

* *readOnly()*</br>
makes the transaction read-only and any attempt to modify the graph will result in an exception.
* *enableBatchLoading()*</br>
 enables batch-loading for an individual transaction. This setting results in similar efficiencies as the graph-wide setting @storage.batch-loading@ due to the disabling of consistency checks and other optimizations. Unlike @storage.batch-loading@ this option will not change the behavior of the storage backend.
* *setTimestamp(long)*</br>
Sets the timestamp for this transaction as communicated to the storage backend for persistence. Depending on the storage backend, this setting may be ignored. For eventually consistent backends, this is the timestamp used to resolve write conflicts. If this setting is not explicitly specified, Titan uses the current time.
* *setCacheSize(long size)*</br> 
The number of vertices this transaction caches in memory. The larger this number, the more memory a transaction can potentially consume. If this number is too small, a transaction might have to re-fetch data which causes delays in particular for long running transactions.
* *checkInternalVertexExistence()*</br> 
Wether this transaction should double-check the existence of vertices during query execution. This can be useful to avoid _phantom vertices_ on eventually consistent storage backends. Disabled by default. Enabling this setting can slow down query processing.

Once, the desired configuration options have been specified, the new transaction is started via @start()@ which returns a @TitanTransaction@.

