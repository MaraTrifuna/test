[[https://github.com/thinkaurelius/titan/raw/master/doc/images/titan-head.png|align=left|float]] It is possible to extend Titan to support other storage layers. This page describes what is required to do this.

<br/>
<br/>
<br/>
<br/>
<br/>

h2. Titan's ID System

Each entity in Titan is assigned a unique id. The last bits of the entity id determine its type:

* If the last bit is 1, then the id denotes an edge
* If the last two bits are 00, then the id denotes a vertex
* If the last two bits are 10, then the id denotes an edge type
  ** If the last three bits are 010, then the id denotes a property type
  ** If the last three bits are 110, then the id denotes a relationship type

Additionally, each entity id is prefixed with a _partition id_ of a fixed bit length. Assume that X bits are designated for the partition identifier, then an entity id would be of the form:
[ 0 | X bits for partition id | Y bits for unique id | 1-3 bits for entity type identification ]
Here, Y denotes the number of bits allocated for specifying a partition id specific unique id. Y will be between 60-X and 62-X depending on the entity type.

For edge types (i.e relationship and property types) there is an additional group id involved that allows us to cluster edge types into groups:
[ 0 | X bits for partition id | G bits for group id | Y' bits for unique id | 1-3 bits for entity type identification ]

When written to the storage layer, the following modifications are made to the ids:
1) ids used as keys are shifted one to the left (i.e. id<<1) so that we use all significant bits which is important for load balancing when using the OrderedPartitioner

2) The edge type is written differently to disk:
[ 2 bits for direction | G bits group id | optional padding to fill up byte] [ edge type id without group id written in flexible length format]
Hence, G should be (n*8 - 2) so that no bits are wasted for padding.