!https://github.com/tinkerpop/blueprints/raw/master/doc/images/blueprints-logo.png!:http://blueprints.tinkerpop.com

"Blueprints":http://blueprints.tinkerpop.com is an open source, community developed Java interface for graph databases. In many ways, Blueprints can be likened to the "JDBC":http://en.wikipedia.org/wiki/Java_Database_Connectivity of the relational database community. Note that any technologies written to work with the Blueprints API can take advantage of a Blueprints-enabled graph database. Example technologies include the open-source products in the "TinkerPop":http://tinkerpop.com stack.

h2. Introduction to TitanGraph

[[https://github.com/thinkaurelius/titan/raw/master/doc/images/juno-married.png|align=center]]

```java
TitanGraph g = TitanFactory.open("/tmp/titan")
Vertex juno = g.addVertex(null);
juno.setProperty("name", "juno");
Vertex jupiter = g.addVertex(null);
jupiter.setProperty("name", "jupiter");
Edge married = g.addEdge(null, juno, jupiter, "married");
```

In the code example above, two vertices were created named "jupiter" and "juno." These two vertices were joined in holy matrimony via a @married@ edge. Please review the "Blueprints Core API":http://tinkerpop.com/docs/javadocs/blueprints/2.0.0/com/tinkerpop/blueprints/package-summary.html for a review of the Blueprints methods available.

h2. Vertex Queries

Continuing with the example above, more vertices are created that are connected to by Juno.

[[https://github.com/thinkaurelius/titan/raw/master/doc/images/super-node.png|align=center]]

```java
Vertex turnus = g.addVertex(null);
turnus.setProperty("name", "turnus");
Vertex hercules = g.addVertex(null);
hercules.setProperty("name", "hercules")
Vertex dido = g.addVertex(null);
dido.setProperty("name", "dido");
Vertex troy = g.addVertex(null);
troy.setProperty("name", "troy");
Vertex jupiter = g.addVertex(null);
jupiter.setProperty("name", "jupiter");

Edge edge = g.addEdge(null, juno, turnus, "knows");
edge.setProperty("since",2010);
edge.setProperty("stars",5);
edge = g.addEdge(null, juno, hercules, "knows");
edge.setProperty("since",2011);
edge.setProperty("stars",1);
edge = g.addEdge(null, juno, dido, "knows");
edge.setProperty("since", 2011);
edge.setProperty("stars", 5);
g.addEdge(null, juno, troy, "likes").setProperty("stars",5);
```

Blueprints (and Titan) supports the notion of "vertex-centric queries":https://github.com/tinkerpop/blueprints/wiki/Vertex-Query which can be understood as a query of the elements directly connected to a vertex (i.e. incident edges or adjacent vertices). An example vertex query is provided below:

bq. Find all the people that Juno greatly admires who she has known since the year 2011.

```java
Iterable<Vertex> results = juno.query().labels("knows").has("since",2011).has("stars",5).vertices()
```

The benefit of a vertex query is that it reduces the amount of data that needs to be pulled off the disk and filtered in-memory. This is important when considering extremely branchy graphs or graphs with "hot spots" called hubs or super-nodes. In these situations, it is imperative to reduce the search space to only that which is required for the particular query. Given the diagrammed graph above, if no restrictions are given to the query (e.g. @juno.query().vertices()@), then 5 vertices are returned. 

```java
for(Vertex vertex : juno.query().vertices()) { 
  System.out.println(vertex.getProperty("name")) 
}

// System.out
hercules
turnus
jupiter
dido
troy
```

However, given the query in the block of code above, only 1 vertex is returned -- the Dido vertex. In this way, intelligent filtering provides performance benefits by reducing the processing and memory footprint required of the consuming application.

```java
for(Vertex vertex : juno.query().labels("knows").has("since",2011).has("stars",5).vertices()) {
  System.out.println(vertex.getProperty("name"));
}

// System.out
dido
```

h2. Deviations from Blueprints Interface

[[https://github.com/tinkerpop/blueprints/raw/master/doc/images/blueprints-character-2.png|width=100px]]

h3. Vertex and Edge Iteration

Titan does not support global vertex or edge iteration. @Graph.getVertices()@ returns an @Iterable@ over only those vertices that are currently loaded in the enclosing transaction. Likewise, @Graph.getEdges()@ returns an @Iterable@ over only those edges which are incident on vertices currently loaded in the enclosing transaction. Unless the entire graph is loaded in the current transaction, this means that @Graph.getVertices()@ and @Graph.getEdges()@ return a (possibly empty) subset of the graph. This deviation from the Blueprints API was introduced to avoid @OutOfMemoryExceptions@ that inevitably happen when attempting to load a huge graph into memory. Global graph operations over Titan graph are handled through "Hadoop":http://hadoop.apache.org/.

This limitation extends to all auxiliary Blueprints functionality that relies on vertex or edge iteration such as graph exporting.

h3. Edge Retrieval

Edges cannot be retrieved by their id in Titan. Only vertices can be retrieved by id.

h3. Key Index Modifications

Key indices must be defined before that key is being used. In other words, the first reference to the key name must be inside the @Graph.createKeyIndex()@ method. If the key has been previously used, creating a key index for that key after the fact will throw an exception. Once a key index has been created it cannot be dropped. These limitations are temporary. Finally, Titan only supports vertex key indices, i.e. @Graph.createKeyIndex("name",Vertex.class)@.

h3. Transactional Scope

Titan strictly enforces the transactional scope, which means that elements created within a transaction are invalid once that transaction is stopped. Operations on invalid elements - other than @getId()@ - may cause an exception. This is done to ensure that operations are not executed on out-of-date elements which could lead to inconsistencies. This is not a deviation from the Blueprints transactional semantic but important to note for users of other graph database frameworks.