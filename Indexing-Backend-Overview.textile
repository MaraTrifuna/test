[[https://raw.github.com/thinkaurelius/titan/master/doc/images/titan-elasticsearch.png|width=150px|align=left|float]]

Titan provides two types of index systems: The _standard_ index and the _external index_ interface which supports an arbitrary number of external indexing backends to provide support for geo, numeric range, and full-text search. 

The standard index is very fast and always available without any further configuration, but only supports exact index matches. In other words, the standard index can only retrieve vertices and edges by matching one of their properties exactly. 

The external index interface is more flexible and supports retrieving vertices and edges by bounding their geo-location, properties that fall into a numeric range or matching tokens in full text. The external index interface connects to separate systems as index backends for indexing and retrieval similarly to how storage backends are used for persistence. Index backends need to be configured in the graph configuration before they can be used.

The choice of index backend determines which search features are supported, as well as the performance and scalability of the index. Titan currently supports two index backends: [[Elastic Search | Using Elastic Search]] and [[Lucene | Using Lucene]].

h2. Indexing Vertices and Edges

To retrieve vertices and edges by their property values through an index lookup, the property key must be registered with the index when it is defined, that is, _before_ its first use. The index is registered through the [[TypeMaker|Type Definition Overview]] when the type is constructed.

For example, the following property key definitions register all four indexed properties from the [[Graph of the Gods example|Getting Started]] with the respective index backends.

```java
// 1) Index vertices by their unique name property
graph.makeType().name("name").dataType(String.class).indexed(Vertex.class).unique(Direction.BOTH).makePropertyKey();
// 2) Index vertices by their age property
graph.makeType().name("age").dataType(Integer.class).indexed("search", Vertex.class).unique(Direction.OUT).makePropertyKey();
// 3) Index edges by their geo-location 
graph.makeType().name("place").dataType(Geoshape.class).indexed("search", Edge.class).unique(Direction.OUT).makePropertyKey();
// 4) Index vertices and edges by their full-text reason property
graph.makeType().name("reason").dataType(String.class).indexed("search",Vertex.class).indexed("search",Edge.class).unique(Direction.OUT).makePropertyKey();
```

# The @name@ property key is indexed for vertices using Titan's standard index. The standard index only supports exact match index retrievals but is very fast. When no index name is specified, the standard index is used.
# The @age@ property key is indexed for vertices using the configured external index backend with the name "search". Since the data type of @age@ is a number, property values are indexed as numbers and can be retrieved via numeric range search.
# The @place@ property key is indexed for edges using the external index backend named "search". Since the data type of @place@ is @Geoshape@, property values are indexed as geo-location and can be retrieved via geo-searches such as circular region or bounding box search (depending on what the index backed supports).
# The @reason@ property key is indexed for vertices _and_ edges using the external index backend named "search". Since the data type of @reason@ is @String@, property values are indexed as text and be retrieved via full-text search such as string-containment search.

***

When using Titan's standard index, the name argument to the @indexed()@ method is optional. An equivalent definition of the @name@ property key, which identifies the standard index by its name, would be:

```java
graph.makeType().name("name").dataType(String.class).indexed("standard",Vertex.class).unique(Direction.BOTH).makePropertyKey();
```

The name "standard" is always reserved for Titan's standard index backend. External indexing backends may not be configured with this name.


_Note, this section assumes that an index backend named @search@ has been defined in the graph configuration. Read "Next Steps" to find out how to configure an index backend._

h2. Querying an Index

h2. Choosing an Index

h2. Next Steps: Configuring an Index Backend

In order to use an external indexing system with Titan, an index backend has to be configured. Titan currently supports two indexing systems:

* [[Lucene|Using Lucene]]: The popular Apache Lucene indexing system
* [[Elasticsearch| Using Elastic Search]]: A distributed indexing system based on Apache Lucene

Refer to the respective documentation pages on how to configure these index backends.

Configuring the index: Lucene, ElasticSearch

h2. Configuration

To configure an instance of an index backend with Titan, one has to give that instance a unique name. That name is important because it is used to identify the index in the initial configuration and when defining vertex and edge key indices in the graph. Once configured, this name cannot be changed.

All index configuration options start with @storage.index@ followed by the name of the index. For instance, to configure the index @search@ to use the elasticsearch index backend, one would add the following configuration option:

```text
storage.index.search.backend=elasticsearch
```

All other configuration options pertaining to that particular index instance would likewise start with @storage.index.search@. Please refer to the documentation pages of the respective index backends for individual configuration options.

h2. Defining Key Indices

Once an index instance has been configured, that instance can be used to index vertices and edges by their properties. To index properties of a particular key, the key has to be defined as _indexed_ when it is first created.

```java
graph.makeType().name("age").dataType(Integer.class).indexed("search", Vertex.class).unique(Direction.OUT).makePropertyKey();
```

In the example above, the property key _age_ is defined and all vertices are indexed by their _age_ property using the _search_ index instance configured previously. To index both vertices and edges by age we would define:

```java
graph.makeType().name("age").dataType(Integer.class).indexed("search", Vertex.class).indexed("search",Edge.class).unique(Direction.OUT).makePropertyKey();
```

h2. Using the Index

Vertices and Edges are retrieved from the index using @GraphQuery@ by specifying a condition on the property key. For instance, the following example retrieves all vertices with an age greater than 50:

```java
g.query().has("age",GREATER_THAN,50).vertices()
```

To query for edges, only the last method changes:

```java
g.query().has("age",GREATER_THAN,50).edges()
```

One can combine multiple conditions to form complex queries. For more examples of global graph index queries, please refer to the [[Getting started]] page.

h2. Next Steps

Read more about the supported index backends:

* [[Using Elastic Search]]
* [[Using Lucene]]